{
    "collab_server" : "",
    "contents" : "---\noutput:\n  pdf_document: default\n  html_document: default\n---\n# Chapter 1: Multi-armed bandits.\n\n\nReinforcement learning can be roughly described as follows: there is an\n**agent** that learns by interaction with the **environment** to perform\na **goal**.\n\nIn many ways it is more *realistic* and *ambitious* than other kinds of\nmachine learning, for instance, supervised learning, where we assume a\nstatic environment and labels, and we know correctly the \"answer\" to our\nactions, it remains to specify the parameter. Some reinforcement\nlearning algorithms use implicitly ideas from supervised learning, as we\nwill see later on.\n\nReinforcement Learning originated from two major branches: Learning in\nanimal psychology (Edward Thorndike, 1911) and Optimal Control and\nDynamic Programming (1950's, but core ideas from 18th century). It\nbelongs to a much wider class of stochastic optimization methods.\n\n\n## The k-armed bandit problem\n\nThe $k$ armed bandit problem can be phrased as follows:\n\n-   There are $k$ possible actions, $\\{a_1, a_2, \\ldots , a_k\\}.$\n-   At time $t = 1, 2, \\ldots ,$ an action is chosen and a reward $R_t$\n    is allocated.\n-   Each action gives an *unknown* reward, sampled from an *unknown*\n    probability distribution.\n-   The reward depends only on the action.\n-   **Goal**: Maximize total reward.\n\nThese are a simpler class of reinforcement learning problems on which there is no influence from the state. Our actions have a noisy effect in the reward and our goal is to learn from these noisy signals, however, the effect of our actions on the reward is not influenced by any other externalities.\n\nBandit algorithms in the real life are used in a number of applications:\n\n\n-   Personalized content/news.\n-   Online advertising (A/B testing and similar).\n    -   A/B testing is a pure exploration phase, followed by pure\n        exploitation.\n-   Clinical trials (experimental treatments for patients while\n    minimizing losses).\n-   Portfolio Optimization.\n\n\n### Solving bandit algorithms\n\nLet's figure out how to deal with bandits before moving on to harder reinforcement learning problems.\n\nAs we said for every action $a_i$, the reward might be still random, but it only\ndepends on the action.\n\n$$ q_*(a_i) := \\mathbb E \\left[ R_t \\ | \\  A_t = a_i \\right], \\ \\ i = 1, 2, \\ldots ,k.$$\n\nTo maximize rewards, we create some estimates of the $q_*$ function\nabove, $$Q_t(a_i) := q_*(a),  \\ i = 1, 2, \\ldots k$$\n\nand use those estimates to choose the best actions. The $q_*$ function is the best possible return we could get from each action, whereas $Q_t$ represents our current estimate of the $q_*$ function based on what we just learned from the interaction. \n\nOne way to learn about $q_*$ is to keep track of the average rewards.\n\n$$Q_t(a_i) := \\frac{\\text{total reward of } a_i \\text{ before  } t}{\\text{times } a_i \\text{  was played  time } t} = \\frac{ \\sum_{j=1}^{t-1}R_j\\cdot 1_{A_j=a_i}}{\\sum_{j=1}^{t-1} 1_{A_j=a_i}}.$$\n\nBy the law of large numbers, if the action is taken infinitely many times,\n\n$$ \\lim_{N_t(a_i) \\to +\\infty} Q_t(a_i) = q_*(a_i).$$\n\n\n### Exploration vs Exploitation\n\nA dilemma that arises in many decision problems is the trade-off between exploration and exploitation. This simply means that if we spend a lot of time trying things randomly, we are risking our reward in the long term, out of low commitment to well-performing actions. Conversely, sticking to something too soon might fire back: imagine we try 2 out of 10 different arms of our bandit, and we just stick to the best of those two. We might be ignoring a much better arm if we don't get adventurous and try it! When we just commit to such action (i.e. the best action seen so far) we say we use a **greedy** policy. \n\n\n-   The **greedy policy** at time $t$ is choosing actions $A_t^*$ such\n    that:\n    $$A_t^* \\  \\in \\ \\mathrm{argmax}_{i = 1, 2, \\ldots ,k} Q_t(a_i).$$\n\n-   If at time $t$ we choose action $A_t$ such that $A_t = A_t^*$ is **exploiting** the action, whereas\n    $A_t \\neq A_t^*$ means **exploring**.\n\n\nOne way to deal with the exploration-exploitation trade-off is to be $\\epsilon$-greedy\n\n\n-   Create an **action-value** table (a Python dictionary) storing the\n    history of the payoffs obtained by each action.\n-   Calculate the average payoff of each action.\n-   Choose with probability $\\epsilon$ a non-optimal action.\n-   Choose with probability $1-\\epsilon$ one of the greedy actions\n    (those with highest average payoff).\n-   Break ties randomly.\n\n\nThe choice of $\\epsilon$ is important, and we can observe different types of behaviour. \n\nThe figures below ilustrate the rewards an agent gets for choosing different arms with different reward probabilities (shown in the third image from the right). The reward is 1 when you get it. So we see that the very conservative player (with small $\\epsilon$ get stuck with a single action from the beginning.\n\nRisk-averse ($\\epsilon = 0.01$)\n![](images/lec5_eps001.png)\n\nOn the opposite behaviour, with a $\\epsilon=1$, we see a player that does a bit better and explores a wider range of actions (in the second picture). However, the mean reward is barely around the average. This is because he is just playing randomly.\n\n\nRisk-taker ($\\epsilon = 1$)\n![](images/lec5_eps1.png)\n\nFinally, we have a mroe balanced agent, which gets a much higher reward in average because is able to identify the correct actions to use with time.\n\nBalance between exploration and exploitation ($\\epsilon = 0.1$)\n![](images/lec5_eps01.png)\n\n\n## Implementation\n\nThere are two important parts for the implementation: on one hand, we have to implement an environment that simulates the reward of the arms. The skeleton of this class is given below:\n\n\n``` python\nclass Arm(object):\n    def __init__(self, params):\n        ## passes the required parameters\n        ## this could be the reward probability, or other parameter (mean, sigma) of a lottery\n        ## that gives the rewards.\n        ...\n        \n    def step(self):\n        ## gives a reward\n        ...\n```\n\nFrom the point of view of the agent, we need to implement the decision making mechanism. The skeleton of this class would beL\n\n``` python\nclass Bandit(object):\n    def __init__(self, *args, **kwargs):\n        ...\n        \n    def reset(self):\n        ...\n            \n    def choose_action(self):\n        ## Chooses a pure action, i.e. an arm\n        ...\n    \n    def update(self, action, reward):\n        #### Updates the values of N and Q\n        ...\n```\n\nAs \n\n```\nimport random\nimport numpy as np\n\ndef argmax(array):\n    return array.index(max(array))\n\nclass EpsilonGreedy:\n    def __init__(self, epsilon, n_actions):\n        self.Q = np.zeros(n_actions)\n        self.N = np.zeros(n_actions)\n        self.epsilon = epsilon     \n        self.n_actions = n_actions\n    \n    def choose_action(self):\n        if random.random()>self.epsilon:\n            a = argmax(self.Q)\n        else:\n            a = random.randint(0,self.n_actions-1)\n        return a\n\tdef update(self, action, reward):\n\t\tn = self.N[action]\n\t\tself.N[action]+=1\n        self.Q[action] = self.Q[action]+1/(self.n_actions)*(reward-self.Q[action])\n```\n\nIn reality, we can also change the value of $\\epsilon$ at every iteration, that is $\\epsilon = \\epsilon_t$, to reduce the exploration rate. As the value of $\\epsilon$ goes to zero, we would approach the greedy policy. Under a good $\\epsilon$ reduction schedule, we would stop the exploration after identifying the good actions. As examples of cooling schedules we have $\\epsilon_t = 1/t$ or $\\epsilon_t = \\epsilon^t$.\n\n## Diagnosing a bandit algorithm\n\nThere are different metrics to see how a bandit algorithm is performing.\n\n-   **Method 1:** Measure how often is the best arm chosen\n    -   That sounds ok, but what if the arms have similar rewards? This metric does not really make sense.\n-   **Method 2:** Average reward at each point in time (is it really\n    getting better?)\n    -   However, this would yield bad average reward for algorithms that explore a lot. So we should be aware of this when we tweak the hyperparameters of our algorith ($\\epsilon$ in this case).\n-   **Method 3:** Cumulative rewards.\n    -   This is a \"Big-picture\" metric: we can see if the cost of exploration was worth.\n\n\n## Other action selection methods\n\nBesides $\\epsilon$-greedy, other action selection methods can be used. We will briefly describe some of them.\n\n### Softmax action selection\n\n\nIt turns out that $\\epsilon$-greedy has the (sometimes unpleasant) property of choosing a really bad action with the same probability as choosing some not-too-bad action. To avoid this, we can choose our action via a mixed strategy $\\pi_t$ (that is, randomizing), using the softmax function:\n\n$$\\pi_t(a_i):= \\frac{e^{Q_t(a_i)/\\tau}}{\\sum^k_{m=1}e^{Q_t(a_m)/\\tau}}.$$\n\nHere $\\tau$ is a parameter, called the **temperature**. In the limit, when $\\tau \\to 0$, softmax action selection behaves like $\\epsilon$-greedy.\n\nFor both softmax and $\\epsilon$-greedy action selection methods, we can decrease the parameters to zero as the number of steps of the episode decreases. This process is called **annealing** and it causes the bandit\nalgorithm to explore less over time.\n\n\n### Upper Confidence Bound action selection\n\nIn this method, we want to be sure of the performance of an action before choosing it. Formally, regret-based estimates are used to give us upper bounds on the true action values. The action selection mechanism is:\n\n$$A_t := \\mathrm{argmax}_{i = 1, \\ldots ,k} \\left[ Q_t(a_i) + 2 \\cdot C\\sqrt{\\frac{\\log t}{N_t(a_i)}} \\right].$$\n\nwhere $C$ is an upper bound for the reward. This gives us a way to control randomness, but it comes at a price. UCB suffers from *back-pedaling*, which roughly means \"I know this is bad, but I'm not completely sure\". So you end up choosing bad actions because you are not completely sure of their true value. It also happens that UCB algorithms may not become strictly greedy.\n\n### Reinforcement Comparison\n\nLast but not least, a method closely related to actor-critic algorithms in reinforcement learning. The motivation behind is simple: How much reward is a good reward? Once we decide on this, we can choose our actions accordingly. The algorithm works as follows:\n\n-   Set $p_t(a_i)$ a learned **preference** for taking action $a_i$.\n-   The policy\n    $\\pi_t(a_i):= \\frac{e^{p_t(a_i)}}{\\sum^k_{m=1}e^{p_t(a_m)}}$ is a\n    mixed strategy.\n-   The preference is updated as:\n    $$p_t(a_i) = p_{t-1}(a) + \\alpha(R_{t-1}-\\bar{R}_{t-1})(1_{A_{t-1}=a_i}-\\pi_{t-1}(a_i))$$\n\nwhere\n\n$$\\bar{R}_{t-1} := \\frac{1}{t-1}\\sum_{j=1}^{t-1}R_j.$$ Note that this reduces to softmax selection for a particular choice of the $p$ function.\n\n## Examples\n\nLet's illustrate a couple of application domains.\n\n### Clinical trials\n\nIn clinical trails, the goal is to evaluate $k$ possible treatments for a disease. Patients are allocated into $k$ groups and the reward is 0 or 1, depending on success of the treatment. This is a typical example where one would rather use softmax than $\\epsilon$-greedy, because it's not the same to choose a random treatment than a second most likely to work. Also, annealing should come in, because in later stages of the trial, a greater fraction of the subjects should be assigned to better treatments.\n\n### Internet advertising\n\nEach time you visit a website the publisher must choose to display one of $k$ ads, and the reward for the publisher is 0/1 (no click/click). However, not all users are alike, and they are not alike to themselves in time. Ads should be in **context** of users' activity. For this, a different class of algorithms, called **contextual bandits** is used. A contextual bandit receives an external signal to know in which context you are, and find, for each context, the best actions for that context. This is almost a reinforcement learning problem, except that the context has no influence in the dynamics to the next state. \n\nA major issue in real life deployments is that reward functions are messy and unspecified in real life.An amusing example of this can be seen in https://blog.openai.com/faulty-reward-functions/, where an agent learns to maximize its reward function as the score on a videogame. However, the agent learns the periodicity in which some bonus-giving tokens are regenerated on screen, and turns over and over in circles instead of finishing the episode.\n\n## Exercises \n\nYou can work on the 10-arm testbed, a classic benchmark for bandit algorithms.\n- Generate randomly 2000 tasks.\n- For each task, you will face a bandit with 10 arms, each arm $i$ has reward chosen from a normal probability distribution with mean $\\mu_i$ and variance 1. The values of $\\mu_i$ should themselves be chosen with a normal distribution with mean 0 and value 1.\n- The task will be run for 1000 episodes\n\n\nYou should compare plays vs \n- number of times the optimal action was chosen.\n- average reward.\n- cumulative reward.\n\nfor $\\epsilon-$ greedy policy, for different values of $\\epsilon$. As a bonus, try softmax and/or UCB.\n\n",
    "created" : 1500731259444.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3054488313",
    "id" : "55858813",
    "lastKnownWriteTime" : 1500731264,
    "last_content_update" : 1500731264716,
    "path" : "C:/Users/pc/Dropbox/dejandolaacademia/manuscript/chapter1.md",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "markdown"
}